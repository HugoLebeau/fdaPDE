#' Plot a \code{FEM} object
#' 
#' @param x A \code{FEM} object.
#' @param num_refinements A natural number specifying how many bisections should by applied to each triangular element for
#' plotting purposes. This functionality is useful where a discretization with 2nd order Finite Element is applied. This parameter can be specified only when a planar mesh (\code{MESH2D} object is plotted.
#' @param ... Arguments representing graphical options to be passed to \link[rgl]{plot3d}.
#' @description Three-dimensional plot of a \code{FEM} object, generated by \code{FEM} or returned by \code{smooth.FEM.basis}, \code{smooth.FEM.PDE.basis} or
#' \code{smooth.FEM.PDE.sv.basis}.
#' @usage \method{plot}{FEM}(x, num_refinements, ...)  
#' @seealso \code{\link{image.FEM}}
#' @examples 
#' ## Upload a triangular mesh and plot it
#' data("mesh.2D.rectangular")
#' plot(mesh.2D.rectangular)
#' ## Create a linear Finite Element basis
#' FEMbasis = create.FEM.basis(mesh.2D.rectangular)
#' ## Define a sinusoidal function as expansion of this basis and plot it
#' coeff <- sin(mesh.2D.rectangular$nodes[,1])*cos(mesh.2D.rectangular$nodes[,2])
#' FEM_object<- FEM(coeff, FEMbasis)
#' plot(FEM_object)

plot.FEM = function(x, num_refinements = NULL, ...)  
{
if(class(x$FEMbasis$mesh)=="MESH2D"){
  if(x$FEMbasis$order == 1)
  {
    R_plot.ORD1.FEM(x, ...)
  }else{
    R_plot.ORDN.FEM(x, num_refinements, ...)
  }
}else if(class(x$FEMbasis$mesh)=="MESH.2.5D"){
  R_plot_manifold(x)
  }
}


#' Image Plot of a FEM
#' 
#' @param x A \code{FEM} object.
#' @param num_refinements A natural number specifying how many bisections should by applied to each triangular element for
#' plotting purposes. This functionality is useful where a discretization with 2nd order Finite Element is applied.
#' @param ... Arguments representing  graphical options to be passed to \link[rgl]{plot3d}.
#' @description Image plot of a \code{FEM} object, generated by the function \code{FEM} or returned by \code{smooth.FEM.basis}, \code{smooth.FEM.PDE.basis} or
#' \code{smooth.FEM.PDE.sv.basis} can be visualized through an image plot. Only planar mesh (\code{MESH2D}) objects can be plotted with this method.
#' @usage \method{image}{FEM}(x, num_refinements, ...)  
#' @seealso \code{\link{plot.FEM}}
#' @examples 
#' ## Upload a triangular mesh and plot it
#' data("mesh.2D.rectangular")
#' plot(mesh.2D.rectangular)
#' ## Create a linear Finite Element basis
#' FEMbasis = create.FEM.basis(mesh.2D.rectangular)
#' ## Define a sinusoidal function as expansion of this basis and plot it
#' coeff <- sin(mesh.2D.rectangular$nodes[,1])*cos(mesh.2D.rectangular$nodes[,2])
#' FEM_object<- FEM(coeff, FEMbasis)
#' image(FEM_object)
image.FEM = function(x, num_refinements = NULL, ...)  
{
  if(x$FEMbasis$order == 1)
  {
    R_image.ORD1.FEM(x, ...)
  }else{
    R_image.ORDN.FEM(x, num_refinements, ...)
  }
}


#' Plot a MESH2D object
#' 
#' @param x A MESH2D object defining the triangular mesh, as generated by \code{create.Mesh.2D} or \code{refine.Mesh.2D}.
#' @param ... Arguments representing graphical options to be passed to \link[graphics]{par}.
#' @description Plot a mesh MESH2D object, generated by \code{create.MESH.2D} or \code{refine.MESH.2D}. Circles indicate the mesh nodes.
#' @usage \method{plot}{MESH2D}(x, ...)
#' @examples 
#' ## Upload the Meuse data and a domain boundary
#' data(MeuseData)
#' data(MeuseBorder)
#' ## Create a triangular mesh with the provided boundary
#' mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = 1)
#' ## Plot it
#' plot(mesh)
plot.MESH2D<-function(x, ...)
{
  plot(x$nodes, xlab="", ylab="", xaxt="n", yaxt="n", bty="n", ...)
  segments(x$nodes[x$edges[,1],1], x$nodes[x$edges[,1],2],
           x$nodes[x$edges[,2],1], x$nodes[x$edges[,2],2], ...)
  segments(x$nodes[x$segments[,1],1], x$nodes[x$segments[,1],2],
           x$nodes[x$segments[,2],1], x$nodes[x$segments[,2],2], col="red", ...)
}
#' Plot a MESH.2.5D object
#'
#' @param mesh A \code{MESH.2.5D} object generated by \code{create.MESH.2.5D} or \code{second.order.MESH.2.5D}.
#' @description Plot the triangulation of a mesh MESH2D object, generated by \code{create.MESH.2.5D} or \code{second.order.MESH.2.5D}.
#' @examples
#' #Load a \code{MESH.2.5D} object
#' data(caramella
#' #Plot the triangulation of the object
#' plot.MESH.2.5D(caramella)


plot.MESH.2.5D<-function(mesh){

  if(!require(rgl)){
    stop("The plot MESH.2.5D_function(...) requires the R package rgl, please install it and try again!")
  }

  order=mesh$order
  nnodes=mesh$nnodes
  ntriangles=mesh$ntriangles

    rgl.open()
    triangle = c(mesh$triangles[1:3*order])-1
    vertices = as.numeric(c(
      mesh$nodes[(3*triangle[1]+1):(3*triangle[1]+3)],1,
      mesh$nodes[(3*triangle[2]+1):(3*triangle[2]+3)],1,
      mesh$nodes[(3*triangle[3]+1):(3*triangle[3]+3)],1))
    bg3d(color = "white")
    indices=c(1,2,3)
    wire3d(tmesh3d(vertices,indices) , col="black")

    for(i in 2:ntriangles){
      #triangle = c(mesh$triangles[3*order*(i-1)+1]-1,mesh$triangles[3*order*(i-1)+2]-1,mesh$triangles[3*order*(i-1)+3]-1)
      triangle = mesh$triangles[(3*order*(i-1)+1):(3*order*(i-1)+3*order)]-1
      vertices = as.numeric(c(
        mesh$nodes[(3*triangle[1]+1):(3*triangle[1]+3)],1,
        mesh$nodes[(3*triangle[2]+1):(3*triangle[2]+3)],1,
        mesh$nodes[(3*triangle[3]+1):(3*triangle[3]+3)],1))

      indices=c(1,2,3)
      wire3d(tmesh3d(vertices,indices) , col="black")
    }

}
