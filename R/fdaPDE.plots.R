#' Plot a \code{FEM} object
#' 
#' @param x A \code{FEM} object.
#' @param num_refinements A natural number specifying how many bisections should by applied to each triangular element for
#' plotting purposes. This functionality is useful where a discretization with 2nd order Finite Element is applied. This parameter can be specified only when a planar mesh (\code{MESH2D} object is plotted.
#' @param ... Arguments representing graphical options to be passed to \link[rgl]{plot3d}.
#' @description Three-dimensional plot of a \code{FEM} object, generated by \code{FEM} or returned by \code{smooth.FEM.basis}, \code{smooth.FEM.PDE.basis} or
#' \code{smooth.FEM.PDE.sv.basis}.
#' @usage \method{plot}{FEM}(x, num_refinements, ...)  
#' @seealso \code{\link{image.FEM}}
#' @examples 
#' ## Upload a triangular mesh and plot it
#' data("mesh.2D.rectangular")
#' plot(mesh.2D.rectangular)
#' ## Create a linear Finite Element basis
#' FEMbasis = create.FEM.basis(mesh.2D.rectangular)
#' ## Define a sinusoidal function as expansion of this basis and plot it
#' coeff <- sin(mesh.2D.rectangular$nodes[,1])*cos(mesh.2D.rectangular$nodes[,2])
#' FEM_object<- FEM(coeff, FEMbasis)
#' plot(FEM_object)

plot.FEM = function(x, num_refinements = NULL, ...)  
{
  if(x$FEMbasis$order == 1)
  {
    R_plot.ORD1.FEM(x, ...)
  }else{
    R_plot.ORDN.FEM(x, num_refinements, ...)
  }
}


#' Image Plot of a FEM
#' 
#' @param x A \code{FEM} object.
#' @param num_refinements A natural number specifying how many bisections should by applied to each triangular element for
#' plotting purposes. This functionality is useful where a discretization with 2nd order Finite Element is applied.
#' @param ... Arguments representing  graphical options to be passed to \link[rgl]{plot3d}.
#' @description Image plot of a \code{FEM} object, generated by the function \code{FEM} or returned by \code{smooth.FEM.basis}, \code{smooth.FEM.PDE.basis} or
#' \code{smooth.FEM.PDE.sv.basis} can be visualized through an image plot. Only planar mesh (\code{MESH2D}) objects can be plotted with this method.
#' @usage \method{image}{FEM}(x, num_refinements, ...)  
#' @seealso \code{\link{plot.FEM}}
#' @examples 
#' ## Upload a triangular mesh and plot it
#' data("mesh.2D.rectangular")
#' plot(mesh.2D.rectangular)
#' ## Create a linear Finite Element basis
#' FEMbasis = create.FEM.basis(mesh.2D.rectangular)
#' ## Define a sinusoidal function as expansion of this basis and plot it
#' coeff <- sin(mesh.2D.rectangular$nodes[,1])*cos(mesh.2D.rectangular$nodes[,2])
#' FEM_object<- FEM(coeff, FEMbasis)
#' image(FEM_object)
image.FEM = function(x, num_refinements = NULL, ...)  
{
  if(x$FEMbasis$order == 1)
  {
    R_image.ORD1.FEM(x, ...)
  }else{
    R_image.ORDN.FEM(x, num_refinements, ...)
  }
}


#' Plot a MESH2D object
#' 
#' @param x A MESH2D object defining the triangular mesh, as generated by \code{create.Mesh.2D} or \code{refine.Mesh.2D}.
#' @param ... Arguments representing graphical options to be passed to \link[graphics]{par}.
#' @description Plot a mesh MESH2D object, generated by \code{create.MESH.2D} or \code{refine.MESH.2D}. Circles indicate the mesh nodes.
#' @usage \method{plot}{MESH2D}(x, ...)
#' @examples 
#' ## Upload the Meuse data and a domain boundary
#' data(MeuseData)
#' data(MeuseBorder)
#' ## Create a triangular mesh with the provided boundary
#' mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = 1)
#' ## Plot it
#' plot(mesh)
plot.MESH2D<-function(x, ...)
{
  plot(x$nodes, xlab="", ylab="", xaxt="n", yaxt="n", bty="n", ...)
  segments(x$nodes[x$edges[,1],1], x$nodes[x$edges[,1],2],
           x$nodes[x$edges[,2],1], x$nodes[x$edges[,2],2], ...)
  segments(x$nodes[x$segments[,1],1], x$nodes[x$segments[,1],2],
           x$nodes[x$segments[,2],1], x$nodes[x$segments[,2],2], col="red", ...)
}
#' Plot a MESH.2.5D object
#'
#' @param mesh A \code{MESH.2.5D} object generated by \code{create.MESH.2.5D} or \code{second.order.MESH.2.5D}.
#' @description Plot the triangulation of a mesh MESH2D object, generated by \code{create.MESH.2.5D} or \code{second.order.MESH.2.5D}.
#' @examples
#' #Load a \code{MESH.2.5D} object
#' data(caramella
#' #Plot the triangulation of the object
#' plot.MESH.2.5D(caramella)


plot.MESH.2.5D<-function(mesh,...){

  if(!require(rgl)){
    stop("The plot MESH.2.5D_function(...) requires the R package rgl, please install it and try again!")
  }
  
  triangles = mesh$triangles
  ntriangles=mesh$ntriangles
  
  order=mesh$order
  
  nodes=matrix(mesh$nodes,nrow=mesh$nnodes,ncol=3,byrow=TRUE)
  
  edges=matrix(rep(0,6*ntriangles),ncol=2)
  for(i in 0:(ntriangles-1)){
  edges[3*i+1,]=c(triangles[3*order*i+1],triangles[3*order*i+2])
  edges[3*i+2,]=c(triangles[3*order*i+1],triangles[3*order*i+3])
  edges[3*i+3,]=c(triangles[3*order*i+2],triangles[3*order*i+3])
  }
  edges=edges[!duplicated(edges),]
  edges<-as.vector(t(edges))
  open3d()
  axes3d()
  rgl.pop("lights") 
  light3d(specular="black") 
  
  rgl.points(x = nodes[ ,1], y = nodes[ ,2], 
                  z=nodes[,3],col="black", ...)
                  
  rgl.lines(x = nodes[edges ,1], y = nodes[edges ,2], 
                  z=nodes[edges,3],col="black",...)
    
  aspect3d("iso")
  rgl.viewpoint(0,-45)

}


